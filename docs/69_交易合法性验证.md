---
id: docs_69
title: 交易合法性验证
sidebar_label: 交易合法性验证
---

**交易合法性验证流程如下：**

## chain 验证交易流程（从链处理验证交易）

1. 验证交易是否存在于交易池中，如果存在则抛弃（txPool.HaveTransaction）

		protocol/txpool/.go
		func (tp *TxPool) HaveTransaction(txHash *bc.Hash) bool {
			return tp.IsTransactionInPool(txHash) || tp.IsTransactionInErrCache(txHash)
		}

2. 验证交易是否为尘埃交易（txPool.IsDust），尘埃交易包括输出为0的交易和是不包含btm资产的交易（比原链）

		protocol/txpool/.go
		func (tp *TxPool) IsDust(tx *types.Tx) bool {
			return isTransactionNoBtmInput(tx) || isTransactionZeroOutput(tx)
		}

## 验证交易合法性 

1. 验证交易版本号、交易size大小、timerange、是否为标准交易等（validation.ValidateTx）

		protocol/validation/tx.go
		func ValidateTx(tx *bc.Tx, block *bc.Block) (*GasState, error) {
			gasStatus := &GasState{GasValid: false}
			if block.Version == 1 && tx.Version != 1 {
				return gasStatus, errors.WithDetailf(ErrTxVersion, "block version %d, transaction version %d", block.Version, tx.Version)
			}
			if tx.SerializedSize == 0 {
				return gasStatus, ErrWrongTransactionSize
			}
			if err := checkTimeRange(tx, block); err != nil {
				return gasStatus, err
			}
			if err := checkStandardTx(tx, block.Height); err != nil {
				return gasStatus, err
			}

			vs := &validationState{
				block:     block,
				tx:        tx,
				entryID:   tx.ID,
				gasStatus: gasStatus,
				cache:     make(map[bc.Hash]error),
			}
			return vs.gasStatus, checkValid(vs, tx.TxHeader)
		}

2. 验证交易输入和输出，并对spend/issue类型的输入执行虚拟机验证（checkValid）。这个里面流程比较多，建议看代码来分解，其验证的内容包括交易输入输出金额是否平衡、先验证BTM资产的手续费的输入输出、交易状态是否合法、执行虚拟机gas的更新等等

	protocol/validation/tx.go
```golang
func checkValid(vs *validationState, e bc.Entry) (err error) {
	var ok bool
	entryID := bc.EntryID(e)
	if err, ok = vs.cache[entryID]; ok {
		return err
	}

	defer func() {
		vs.cache[entryID] = err
	}()

	switch e := e.(type) {
	case *bc.TxHeader:
		for i, resID := range e.ResultIds {
			resultEntry := vs.tx.Entries[*resID]
			vs2 := *vs
			vs2.entryID = *resID
			if err = checkValid(&vs2, resultEntry); err != nil {
				return errors.Wrapf(err, "checking result %d", i)
			}
		}

		if e.Version == 1 && len(e.ResultIds) == 0 {
			return ErrEmptyResults
		}

	case *bc.Mux:
		parity := make(map[bc.AssetID]int64)
		for i, src := range e.Sources {
			if src.Value.Amount > math.MaxInt64 {
				return errors.WithDetailf(ErrOverflow, "amount %d exceeds maximum value 2^63", src.Value.Amount)
			}
			sum, ok := checked.AddInt64(parity[*src.Value.AssetId], int64(src.Value.Amount))
			if !ok {
				return errors.WithDetailf(ErrOverflow, "adding %d units of asset %x from mux source %d to total %d overflows int64", src.Value.Amount, src.Value.AssetId.Bytes(), i, parity[*src.Value.AssetId])
			}
			parity[*src.Value.AssetId] = sum
		}

		for i, dest := range e.WitnessDestinations {
			sum, ok := parity[*dest.Value.AssetId]
			if !ok {
				return errors.WithDetailf(ErrNoSource, "mux destination %d, asset %x, has no corresponding source", i, dest.Value.AssetId.Bytes())
			}
			if dest.Value.Amount > math.MaxInt64 {
				return errors.WithDetailf(ErrOverflow, "amount %d exceeds maximum value 2^63", dest.Value.Amount)
			}
			diff, ok := checked.SubInt64(sum, int64(dest.Value.Amount))
			if !ok {
				return errors.WithDetailf(ErrOverflow, "subtracting %d units of asset %x from mux destination %d from total %d underflows int64", dest.Value.Amount, dest.Value.AssetId.Bytes(), i, sum)
			}
			parity[*dest.Value.AssetId] = diff
		}

		for assetID, amount := range parity {
			if assetID == *consensus.BTMAssetID {
				if err = vs.gasStatus.setGas(amount, int64(vs.tx.SerializedSize)); err != nil {
					return err
				}
			} else if amount != 0 {
				return errors.WithDetailf(ErrUnbalanced, "asset %x sources - destinations = %d (should be 0)", assetID.Bytes(), amount)
			}
		}

		for _, BTMInputID := range vs.tx.GasInputIDs {
			e, ok := vs.tx.Entries[BTMInputID]
			if !ok {
				return errors.Wrapf(bc.ErrMissingEntry, "entry for bytom input %x not found", BTMInputID)
			}

			vs2 := *vs
			vs2.entryID = BTMInputID
			if err := checkValid(&vs2, e); err != nil {
				return errors.Wrap(err, "checking gas input")
			}
		}

		for i, dest := range e.WitnessDestinations {
			vs2 := *vs
			vs2.destPos = uint64(i)
			if err = checkValidDest(&vs2, dest); err != nil {
				return errors.Wrapf(err, "checking mux destination %d", i)
			}
		}

		if err := vs.gasStatus.setGasValid(); err != nil {
			return err
		}

		for i, src := range e.Sources {
			vs2 := *vs
			vs2.sourcePos = uint64(i)
			if err = checkValidSrc(&vs2, src); err != nil {
				return errors.Wrapf(err, "checking mux source %d", i)
			}
		}

	case *bc.Output:
		vs2 := *vs
		vs2.sourcePos = 0
		if err = checkValidSrc(&vs2, e.Source); err != nil {
			return errors.Wrap(err, "checking output source")
		}

	case *bc.Retirement:
		vs2 := *vs
		vs2.sourcePos = 0
		if err = checkValidSrc(&vs2, e.Source); err != nil {
			return errors.Wrap(err, "checking retirement source")
		}

	case *bc.Issuance:
		computedAssetID := e.WitnessAssetDefinition.ComputeAssetID()
		if computedAssetID != *e.Value.AssetId {
			return errors.WithDetailf(ErrMismatchedAssetID, "asset ID is %x, issuance wants %x", computedAssetID.Bytes(), e.Value.AssetId.Bytes())
		}

		gasLeft, err := vm.Verify(NewTxVMContext(vs, e, e.WitnessAssetDefinition.IssuanceProgram, e.WitnessArguments), vs.gasStatus.GasLeft)
		if err != nil {
			return errors.Wrap(err, "checking issuance program")
		}
		if err = vs.gasStatus.updateUsage(gasLeft); err != nil {
			return err
		}

		destVS := *vs
		destVS.destPos = 0
		if err = checkValidDest(&destVS, e.WitnessDestination); err != nil {
			return errors.Wrap(err, "checking issuance destination")
		}

	case *bc.Spend:
		if e.SpentOutputId == nil {
			return errors.Wrap(ErrMissingField, "spend without spent output ID")
		}
		spentOutput, err := vs.tx.Output(*e.SpentOutputId)
		if err != nil {
			return errors.Wrap(err, "getting spend prevout")
		}

		gasLeft, err := vm.Verify(NewTxVMContext(vs, e, spentOutput.ControlProgram, e.WitnessArguments), vs.gasStatus.GasLeft)
		if err != nil {
			return errors.Wrap(err, "checking control program")
		}
		if err = vs.gasStatus.updateUsage(gasLeft); err != nil {
			return err
		}

		eq, err := spentOutput.Source.Value.Equal(e.WitnessDestination.Value)
		if err != nil {
			return err
		}
		if !eq {
			return errors.WithDetailf(
				ErrMismatchedValue,
				"previous output is for %d unit(s) of %x, spend wants %d unit(s) of %x",
				spentOutput.Source.Value.Amount,
				spentOutput.Source.Value.AssetId.Bytes(),
				e.WitnessDestination.Value.Amount,
				e.WitnessDestination.Value.AssetId.Bytes(),
			)
		}

		vs2 := *vs
		vs2.destPos = 0
		if err = checkValidDest(&vs2, e.WitnessDestination); err != nil {
			return errors.Wrap(err, "checking spend destination")
		}

	case *bc.Coinbase:
		if vs.block == nil || len(vs.block.Transactions) == 0 || vs.block.Transactions[0] != vs.tx {
			return ErrWrongCoinbaseTransaction
		}

		if *e.WitnessDestination.Value.AssetId != *consensus.BTMAssetID {
			return ErrWrongCoinbaseAsset
		}

		if e.Arbitrary != nil && len(e.Arbitrary) > consensus.CoinbaseArbitrarySizeLimit {
			return ErrCoinbaseArbitraryOversize
		}

		vs2 := *vs
		vs2.destPos = 0
		if err = checkValidDest(&vs2, e.WitnessDestination); err != nil {
			return errors.Wrap(err, "checking coinbase destination")
		}
		vs.gasStatus.StorageGas = 0

	default:
		return fmt.Errorf("entry has unexpected type %T", e)
	}

	return nil
}
```

## 验证交易UTXO

1. 验证交易输入的UTXO是否存在、或是否已被花费（CanSpend）

		protocol/state/utxo_view.go
		func (view *UtxoViewpoint) CanSpend(hash *bc.Hash) bool {
			entry := view.Entries[*hash]
			return entry != nil && !entry.Spent
		}

2. 验证交易是否为孤儿交易（即UTXO不存在的交易），因为网络传输导致的情况（checkOrphanUtxos），如果是则加入交易孤儿交易池中

		protocol/txpool/.go
		func (tp *TxPool) checkOrphanUtxos(tx *types.Tx) ([]*bc.Hash, error) {
			view := state.NewUtxoViewpoint()
			if err := tp.store.GetTransactionsUtxo(view, []*bc.Tx{tx.Tx}); err != nil {
				return nil, err
			}
			hashes := []*bc.Hash{}
			for _, hash := range tx.SpentOutputIDs {
				if !view.CanSpend(&hash) && tp.utxo[hash] == nil {
					hashes = append(hashes, &hash)
				}
			}
			return hashes, nil
		}

