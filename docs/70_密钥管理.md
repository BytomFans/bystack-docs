---
id: docs_70
title: 密钥管理
sidebar_label: 密钥管理
---



## 生成

### 生成根密钥

**输入：**`seed`，种子字节序列（变量长度，至少256比特随机数）。

**输出：**`xprv`，扩展私钥。

1. 计算`I = Hash512("Chain seed" || seed)`。
2. 把I分成两部分：32字节的`buf`和32字节的`salt`。
3. 从缓冲器`buf`中[生成秘密标量](#生成秘密标量)`s`。
4. 假设`privkey`是用32字节字符串以小端字节序编码的标量`s`。
5. 返回`xprv = privkey || salt (64 字节)`。



### 生成扩展公钥

**输入：**`xprv`，扩展私钥。

**输出：**`xpub`，扩展公钥。

1. 把xprv分成两部分：32字节的`privkey`和32字节的`salt`。
2. 私钥`privkey`是256比特整型s转成小端字节序。
3. 做固定基标量乘算法`P = s*B`，其中`B`是Ed25519的基点。
4. [编码](#编码公钥)点`P`作为`pubkey`。
5. 返回扩展公钥`xpub = pubkey || salt`（64字节）。



### 衍生强化扩展私钥

**输入：**
1. `xprv`，扩展私钥。
2. `selector`，可变长度字节序列用作衍生金钥。

**输出：**`xprv'`，衍生强化扩展公钥。

1. 把`xprv`分成两部分：32字节的`privkey`和32字节的`salt`。
2. 使`len`为`selector`的字节长度。
3. 使`I = Hash512(0x00 || privkey || salt || LEB128(len) || selector)`。
4. 把`I`分成两部分：32字节的`buf`和32字节的`salt'`。
5. 从缓冲器`buf`中[生成秘密标量](#生成秘密标量)`s'`。
6. 假设`privkey'`是用32字节字符串以小端字节序编码的标量`s'`。
7. 返回`xprv' = privkey' || salt'`。



### 衍生非强化扩展私钥

**输入：**
1. `xprv`，扩展私钥。
2. `selector`，可变长度字节序列用作衍生金钥。

**输出：**`xprv'`，衍生强化扩展公钥。

1. 把`xprv`分成两部分：32字节的`privkey`和32字节的`salt`。
2. 使`s`为从`privkey`以以小端字节序解码的标量。
3. 做固定基标量乘算法`P = s*B`，其中`B`是Ed25519的基点。
4. [编码](#编码公钥)点`P`作为`pubkey`。
5. 使`len`为`selector`的字节长度。
6. 使`I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)`。
7. 把`I`分成两部分：32字节的`fbuffer`和32字节的`salt'`。
8. 从缓冲器`fbuffer`中[生成秘密标量](#生成秘密标量)`f`。
9. 计算衍生秘密标量`s' = (f + s) mod L`（其中L代表B的分组排序）。
10. 假设`privkey'`是用32字节字符串以小端字节序编码的标量`s'`。
11. 返回`xprv' = privkey' || salt'`。



### 衍生非强化扩展公钥

**输入：**
1. `xpub`，扩展公钥。
2. `selector`，可变长度字节序列用作衍生金钥。

**输出：**`xpub'`，衍生强化扩展公钥。

1. 把`xpub`分成两部分：32字节的pubkey和32字节的`salt`。
2. 使`len`为`selector`的字节长度。
3. 使`I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)`。
4. 把`I`分成两部分：32字节的`fbuffer`和32字节的`salt'`。
5. 从缓冲器`fbuffer`中[生成秘密标量](#生成秘密标量)`f`。
6. 做固定基标量乘算法`F = f*B`，其中`B`是Ed25519的基点。
7. 根据EdDSA从`pubkey`解码点`P`。
8. 做点加法`P' = P + F`。
9. [编码](#编码公钥)点`P'`作为`pubkey'`。
10. 返回`xpub' = pubkey' || salt'`。



## KeyStore文件



## 签名

### 签名

**输入：**
1. `xprv`，扩展私钥。
2. `message`，表示待签名的明文的可变长度字节序列。

**输出：**`(R,S)`，表示EdDSA签名的64字节字符串。

1. 拆分`xprv`为两个部分：32字节`privkey`和32字节`salt`。
2. 假设`s`是`privkey`使用小端字节序解码的标量。
3. 让`h = Hash512(0x02 || privkey || salt)`。
4. 假设`prefix`是`h：prefix = h[0:32]`的第一部分。
5. 执行固定基数标量乘法`P = s*B`，其中`B`是Ed25519的基点。
6. 将点`P`[编码](#编码公钥)为`pubkey`。
7. 计算`Hash512(prefix || message)`将64字节digest密文转成小端字节序排列的整型`r`。
8. 计算点`r*B`。 为了提高效率，用先做`r`模`L`降低计算复杂度，用`B`的分组排序。
9. 令字符串`R`为点`r*B`的编码。
10. 计算`Hash512(R || pubkey || message)`并将64字节digest密文转成小端字节序排列的整型`k`。
11. 计算`S = (r + k * s) mod L`。为了提高效率，再次先做`k`模`L`。
12. 将`R`（32字节）和小端字节序编码的`S`（32个字节，最后一个字节的三个最高有效位始终为零）合并。
13. 返回`(R,S)`（64字节）。



### 验证签名


[RFC 8032]



### 生成秘密标量



### 编码公钥



## 参考资料
[RFC 8032]: https://tools.ietf.org/html/rfc8032