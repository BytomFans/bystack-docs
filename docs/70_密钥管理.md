---
id: docs_70
title: 密钥管理
sidebar_label: 密钥管理
---

## ChainKD

比原链确定性密钥派生方案，由两个使用不同哈希函数的实例组成：

**ChainKD2：** 哈希函数为SHA2-512（如EdDSA规范中所示）

**ChainKD3：** 哈希函数为SHA3-512

**特征：**

- 该方案已经完全确定，可以从一个高熵种子（high-entropy seed）生成结构复杂的密钥。
- 使用“硬化派生”从扩展私钥派生私钥
- 使用“非硬化派生”私钥独立派生公钥。
- 硬化公钥、非硬化公钥和签名与EdDSA规范兼容。
- 用字节长度可变的串选择符（selector），而不是固定长度的整型索引。
- 没有特殊编码的短64字节扩展公钥和私钥。
- 没有元数据：扩展密钥仅携带额外的32字节的盐值，以避免派生函数仅依赖于密钥本身。
- 隐私：扩展密钥既不显示其在层次结构中的位置，也不显示派生的方式（硬化或非硬化）。

**定义**

- **Hash512**：具有512比特输出（SHA2-512或SHA3-512）的加密哈希函数，
- **选择符**：字节长度可变的字符串，可以用作派生索引
- **秘密标量**：32字节的字符串，表示使用小端字节序排列的256比特整型
- **公钥** ：32字节的字符串，表示椭圆曲线Ed25519 RFC 8032上的一个点
- **扩展私钥**（xprv）：64字节的字符串，表示可用于派生子扩展私钥和公钥的密钥
- **扩展公钥**（xpub）：64字节的字符串，表示可用于派生子扩展公钥的密钥
- **LEB128**：用小端字节序Base-128编码的无符号整型，用于可变长度选择符字符串的长度前缀。

**安全**

种子或根扩展私钥：

- 可派生硬化扩展私钥
- 可派生非硬化扩展私钥
- 可使用根密钥签名信息

扩展私钥：

- 可派生硬化扩展私钥
- 可派生非硬化扩展私钥
- 可使用根密钥签名信息

扩展公钥：

- 可派生非硬化公钥
- 无法确定它是以硬化还是非硬化方式派生的
- 无法确定另一个扩展公钥是否与该密钥同级
- 无法签名
- 无法派生私钥
- 无法派生硬化公钥

父级扩展公钥和非硬化派生扩展私钥：

- 可提取父私钥：`s = (s' - f) mod L`，其中`f`是从父`xpub`派生，`s'`从子`xprv'`提取。

## 生成

### 生成根密钥

**输入：**

`seed`: 种子字节序列（变量长度，至少256比特随机数）

**输出：**

`xprv`: 扩展私钥

**算法：**

1. 用HMAC认证sha512以"Root"为key加密`seed`得到`xprv = Hash512("Root" || seed)`。
2. `xprv`的前32位做修剪根标量（清除第一个字节的最低3位，清除最后一个字节的最高3位，并设定最后一个字节的第二高位）。

### 生成扩展公钥

**输入：**

`xprv`: 扩展私钥。

**输出：**

`xpub`: 扩展公钥。

**算法：**

1. 把xprv分成两部分：32字节的`scalar`和32字节的`salt`。
2. 做固定基点标量乘算法`P = s*B`，其中`B`是Ed25519的基点。
3. [编码](#编码公钥)点`P`作为`buf`。
4. 返回扩展公钥`xpub = buf || salt`（64字节）。

### 衍生硬化扩展私钥

**输入：**

`xprv`: 扩展私钥

`selector`: 字节长度可变的序列用作派生金钥

**输出：**

`xprv'`: 派生硬化扩展公钥

**算法:**

1. 把`xprv`分成两部分：32字节的`xprv`和32字节的`salt`。
2. 用HMAC认证sha512以salt为key加密`('H' || salt || selector)`得到`xprv = Hash512(xprv || 'H' || salt || selector)`。
3. `xprv`的前32位做修剪根标量（清除第一个字节的最低3位，清除最后一个字节的最高3位，并设定最后一个字节的第二高位）。

### 衍生非硬化扩展私钥

**输入：**

`xprv`:扩展公钥

`selector`: 字节长度可变的序列用作派生金钥

**输出：**

`xprv`: 派生非硬化扩展私钥

**算法：**

1. 把`xpub`分成两部分：32字节的`xpub`和32字节的`salt`。
2. 用HMAC认证sha512以salt为key加密得到`res = Hash512(xpub || 'N' || salt || selector)`。
3. `res`的前32位做修剪根标量（清除第一个字节的最低3位，清除倒数第三个字节的最前7位，清除倒数第两个字节的所有位）。
4. 用小端字节序编码`res`的前32字节。
5. `xprv` = `res`

### 派生非硬化扩展公钥

**输入：**

`xpub`: 扩展公钥

`selector`:字节长度可变的序列用作派生金钥

**输出：**

`xpub`，派生非硬化扩展公钥

**算法：**

1. 把`xpub`分成两部分：32字节的`xpub`和32字节的`salt`。
2. 用HMAC认证sha512以salt为key加密得到`res = Hash512(xpub || 'N' || salt || selector)`。
3. `res`的前32位做修剪根标量（清除第一个字节的最低3位，清除倒数第三个字节的最前7位，清除倒数第两个字节的所有位）。
4. 把`res`分成两部分：32字节的`f`和32字节的`salt'`
5. 做固定基标量乘算法`F = f*B`，其中`B`是Ed25519的基点
6. `xpub`赋值给`pubkey`
7. 做点加法`P' = P + F`
8. [编码](#编码公钥)点`P'`作为`pubkey'`
9. 返回`xpub' = pubkey' || salt'`

## Keystore文件

Keystore的本质是加密后的私钥，Keystore必须配合你的钱包密码来使用。

**Keystore文件数据结构**

| 字段 | 类型 | 描述 | 
| --- | --- |--- |
|ID | uuid.UUID |   用户 uid |
|KeyType | string | 私钥类型  |
|Alias |	string	|  账户别名 |
|XPrv | chainkd.XPrv |公钥|
|XPub | chainkd.XPub |  私钥  |

## 签名

### 签名

**输入：**

`xprv`: 扩展私钥。

`message`: 表示待签名的信息的字节长度可变的序列

**输出：**

`(R,S)`: 表示EdDSA签名的64字节字符串

**算法：**

1. 拆分`xprv`为两个部分：32字节`privkey`和32字节`salt`
2. 假设`s`是`privkey`使用小端字节序解码的标量
3. 让`h = Hash512(0x02 || privkey || salt)`
4. 假设`prefix`是`h`的前半部分：`prefix = h[0:32]`
5. 执行固定基数标量乘法`P = s*B`，其中`B`是Ed25519的基点
6. 将点`P`[编码](#编码公钥)为`pubkey`
7. 计算`Hash512(prefix || message)`将64字节digest密文转成小端字节序排列的整型`r`
8. 计算点`r*B`。 为了提高效率，用先做`r`模`L`降低计算复杂度，其中L是`B`的阶（group order）
9. 令字符串`R`为点`r*B`的[编码](#编码公钥)
10. 计算`Hash512(R || pubkey || message)`并将64字节digest密文转成小端字节序排列的整型`k`
11. 计算`S = (r + k * s) mod L`。为了提高效率，再次先做`k`模`L`。
12. 将`R`（32字节）和小端字节序编码的`S`（32个字节，最后一个字节的三个最高有效位始终为零）合并
13. 返回`(R,S)`（64字节）

### 验证签名

**输入：**

`xprv`: 扩展公钥

`message`: 表示已签名的信息的字节长度可变的序列

`(R,S)`: 64字节签名

**输出：**

判断签名是否有效的布尔值（boolean value）

**算法：**

1. 提取公钥`pubkey`作为`xpub`的前32字节。
2. 根据[RFC 8032]使用`pubkey`并把Hash512替换SHA512哈希函数
，验证`message`上的验证EdDSA签名`(R,S)`（ChainKD-SHA2实例中，Hash512等于SHA512，从而保证验证过程与EdDSA完全兼容）

### 生成秘密标量

**输入：**

`buffer`: 32字节字符串。

**输出：**

`s`: 256比特整型

**计算:**

1. 修剪缓冲器`buffer`：清除第一个字节的最低3位，剪除最末字节的最高位，设定最末字节的第二高位
2. `buffer`被设作小端字节序整型，形成标量`s`
3. 返回`s`

### 编码公钥

**输入：**

`P`: Ed25519曲线的点

**输出：**

`pubkey`: 32字节字符串代表一个Ed25519曲线的点

**算法：**

1. 首先，将纵坐标（y coordinate）编码（在0 <= y < p的范围内）成32字节的小端字节序字符串。最末字节的最高有效位始终为零
2. 将横坐标（x coordinate）的最末位字节的最低有效位复制给最高有效位，形成点`P`的编码
3. 返回产生的32字节字符串记作`pubkey`
