---
id: docs_70
title: 密钥管理
sidebar_label: 密钥管理
---

## 生成
生成根密钥
输入：seed，种子字节序列（变量长度，至少256比特随机数）
输出：xprv，扩展私钥
1. 计算 I = Hash512("Chain seed" || seed)
2. 把I分成两部分：32字节的buf和32字节的salt
3. 从缓冲器buf中生成秘密标量s
4. 假设privkey是用32字节字符串以小端字节序编码的标量s
5. 返回 xprv = privkey || salt (64 字节)

生成扩展公钥
输入：xprv，扩展私钥
输出：xpub，扩展公钥
1. 把xprv分成两部分：32字节的privkey和32字节的salt
2. 私钥privkey是256比特整型s转成小端字节序
3. 做固定基标量乘算法 P = s*B，其中B是Ed25519的基点
4. 编码点P作为pubkey
5. 返回扩展公钥 xpub = pubkey || salt (64 字节)

衍生强化扩展私钥
输入：
1. xprv，扩展私钥
2. selector，可变长度字节序列用作衍生金钥
输出：xprv'，衍生强化扩展公钥
1. 把xprv分成两部分：32字节的privkey和32字节的salt
2. 使len为selector的字节长度
3. 使 I = Hash512(0x00 || privkey || salt || LEB128(len) || selector)
4. 把I分成两部分：32字节的buf和32字节的salt'
5. 从缓冲器buf中生成秘密标量s'
6. 假设privkey'是用32字节字符串以小端字节序编码的标量s'
7. 返回 xprv' = privkey' || salt'

衍生非强化扩展私钥
输入：
1. xprv，扩展私钥
2. selector，可变长度字节序列用作衍生金钥
输出：xprv'，衍生强化扩展公钥
1. 把xprv分成两部分：32字节的privkey和32字节的salt
2. 使s为从privkey以以小端字节序解码的标量
3. 做固定基标量乘算法 P = s*B，其中B是Ed25519的基点
4. 编码点P作为pubkey
5. 使len为selector的字节长度
6. 使 I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)
7. 把I分成两部分：32字节的fbuffer和32字节的salt'
8. 从缓冲器fbuffer中生成秘密标量f
9. 计算衍生秘密标量 s' = (f + s) mod L (其中L代表B的分组排序)
10. 假设privkey'是用32字节字符串以小端字节序编码的标量s'
11. 返回 xprv' = privkey' || salt'

衍生非强化扩展公钥
输入：
1. xpub，扩展公钥
2. selector，可变长度字节序列用作衍生金钥
输出：xpub'，衍生强化扩展公钥
1. 把xpub分成两部分：32字节的pubkey和32字节的salt
2. 使len为selector的字节长度
3. 使 I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)
4. 把I分成两部分：32字节的fbuffer和32字节的salt'
5. 从缓冲器fbuffer中生成秘密标量f
6. 做固定基标量乘算法 F = f*B，其中B是Ed25519的基点
7. 根据EdDSA从pubkey解码点P
8. 做点加法 P' = P + F
9. 编码点P'作为pubkey'
10. 返回 xpub' = pubkey' || salt'


## KeyStore文件



## 签名

输入：
1. xprv，扩展私钥。
2. message，表示待签名的明文的可变长度字节序列。
输出：(R,S)，表示EdDSA签名的64字节字符串。
1. 拆分xprv为两个部分：32字节privkey和32字节salt。
2. 假设s是privkey使用little-endian表示法解码的标量。
3. 让 h = Hash512(0x02 || privkey || salt)。
4. 假设prefix是h：prefix = h[0:32]的第一部分。
5. 执行固定基数标量乘法 P = s*B，其中B是Ed25519的基点。
6. 将点P编码为pubkey。
7. 计算 Hash512(prefix || message)将64字节digest密文转成little-endian排列的整型r。
8. 计算点r*B。 为了提高效率，用先做r模L降低计算复杂度，用B的分组排序。
9. 令字符串R为点r*B的编码。
10. 计算 Hash512(R || pubkey || message)并将64字节digest密文转成小端字节序排列的整型k。
11. 计算 S = (r + k * s) mod L。为了提高效率，再次先做k模L。
12. 将R（32字节）和小端字节序编码的S（32个字节，最后一个字节的三个最高有效位始终为零）合并。
13. 返回(R,S)（64字节）。


