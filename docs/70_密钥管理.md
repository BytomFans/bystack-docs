---
id: docs_70
title: 密钥管理
sidebar_label: 密钥管理
---

## 生成
生成根密钥
输出：xprv，扩展私钥
1. 计算 I = Hash512("Chain seed" || seed)
2. 把I分成两部分：32字节的buf和32字节的salt
3. 从缓冲器buf中生成秘密标量s
4. 使privkey = 用32字节字符串以小端字节序加密标量s
5. 返回 xprv = privkey || salt (64 字节)

生成扩展公钥
输入：xprv，扩展私钥
输出：xpub，扩展公钥
1. 把xprv分成两部分：32字节的privkey和32字节的salt
2. 私钥privkey是256比特整型s转成小端字节序
3. 做固定基标量乘算法P = s*B，B是Ed25519的基点
4. 点P转码作为pubkey
5. 返回扩展公钥xpub = pubkey || salt (64 字节)

衍生强化扩展私钥
输入：
1. xprv，扩展私钥
2. selector，长度可变的字节序列用作衍生金钥
输出：xprv'，衍生强化扩展公钥
1. 把xprv分成两部分：32字节的privkey和32字节的salt
2. 使len为selector的字节长度
3. 使I = Hash512(0x00 || privkey || salt || LEB128(len) || selector)
4. 把I分成两部分：32字节的buf和32字节的salt'
5. 从缓冲器buf中生成秘密标量s'
6. 使privkey' = 用32字节字符串以小端字节序加密标量s'
7. 返回xprv' = privkey' || salt'

衍生非强化扩展私钥
输入：
1. xprv，扩展私钥
2. selector，长度可变的字节序列用作衍生金钥
输出：xprv'，衍生强化扩展公钥
1. 把xprv分成两部分：32字节的privkey和32字节的salt
2. 使s为从privkey以以小端字节序解码的标量
3. 做固定基标量乘算法P = s*B，B是Ed25519的基点
4. 点P转码作为pubkey
5. 使len为selector的字节长度
6. 使I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)
7. 把I分成两部分：32字节的fbuffer和32字节的salt'
8. 从缓冲器fbuffer中生成秘密标量f
9. 计算衍生秘密标量s’ = (f + s) mod L (L是B的分组排序)
10. 使privkey' = 用32字节字符串以小端字节序加密标量s'
11. 返回xprv' = privkey' || salt'

衍生非强化扩展公钥
输入：
1. xpub，扩展公钥
2. selector，长度可变的字节序列用作衍生金钥
输出：xpub'，衍生强化扩展公钥
1. 把xpub分成两部分：32字节的pubkey和32字节的salt
2. 使len为selector的字节长度
3. 使I = Hash512(0x01 || pubkey || salt || LEB128(len) || selector)
4. 把I分成两部分：32字节的fbuffer和32字节的salt'
5. 从缓冲器fbuffer中生成秘密标量f
6. 做固定基标量乘算法F = f*B，B是Ed25519的基点
7. 根据EdDSA从pubkey解码点P
8. 做点加法P' = P + F
9. 转码点P'作为pubkey'
10. 返回xpub' = pubkey' || salt'


## KeyStore文件



## 签名



**sign**

输入：

xprv，扩展的私钥。
message，表示要签名的消息的可变长度字节序列。
输出： (R,S)，表示EdDSA签名的64字节字符串。

拆分xprv为两个部分：32字节privkey和32字节salt。
假设s是privkey使用little-endian表示法解码的标量。
让h = Hash512(0x02 || privkey || salt)。
我们prefix是上半年h：prefix = h[0:32]。
执行固定基数标量乘法P = s*B，其中BEd25519是基点。
将点编码P为pubkey。
计算Hash512(prefix || message)。将64字节的摘要解释为little-endian整数r。
计算点r*B。为了提高效率，请先降低的r模数L（的组顺序）来实现B。
令字符串R为point的编码r*B。
计算Hash512(R || pubkey || message)并将64字节的摘要解释为little-endian整数k。
计算S = (r + k * s) mod L。为了提高效率，请再次降低k模数L。
串联R（32个字节），并进行Little-endian编码S（32个字节，最后一个字节的三个最高有效位始终为零）。
返回(R,S)（64个字节）。